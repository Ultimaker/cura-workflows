name: Conan Package Discovery by Jira Ticket

on:
  workflow_call:
    inputs:
      jira_ticket_number:
        default: ''
        required: true
        type: string
      channel:
        default: 'ultimaker'
        required: false
        type: string
    outputs:
      discovered_packages:
        description: "All discovered packages"
        value: ${{ jobs.find-packages.outputs.discovered_packages }}
      cura_package:
        description: "Cura package"
        value: ${{ jobs.find-packages.outputs.cura_package }}
      package_overrides:
        description: "Overrides"
        value: ${{ jobs.find-packages.outputs.package_overrides }}

permissions:
  contents: read

jobs:
  find-packages:
    runs-on: ubuntu-latest
    outputs:
      discovered_packages: ${{ steps.conan_search.outputs.discovered_packages }}
      cura_package: ${{ steps.conan_search.outputs.cura_package }}
      package_overrides: ${{ steps.conan_search.outputs.package_overrides }}
    steps:
      - name: Checkout repository code
        uses: actions/checkout@v4

      - name: Validate Jira Ticket Number Format
        id: validate_input
        uses: actions/github-script@v7
        with:
          script: |
            const inputTicket = '${{ inputs.jira_ticket_number }}';
            let normalizedTicket = inputTicket.toLowerCase().replace(/-/g, '_');

            if (/^[0-9]+$/.test(normalizedTicket)) {
              normalizedTicket = `cura_${normalizedTicket}`;
            }

            const keyword = normalizedTicket.split('_')[0];
            const numberMatch = normalizedTicket.match(/[0-9]+/);
            const number = numberMatch ? numberMatch[0] : null;

            if (!['cura', 'np', 'pp'].includes(keyword)) {
              return core.setFailed("Invalid Jira ticket keyword. Expected one of: cura, np, pp.");
            }
            if (number === null) {
              return core.setFailed("No number found in Jira ticket input.");
            }

            const fixedTicket = `${keyword}_${number}`;
            console.log(`Jira ticket number normalized to '${fixedTicket}'.`);
            core.setOutput('jira_ticket_number', fixedTicket);

      - name: Setup the build environment
        uses: ultimaker/cura-workflows/.github/actions/setup-build-environment@main
        with:
          conan_user: ${{ secrets.CONAN_USER }}
          conan_password: ${{ secrets.CONAN_PASS }}
          private_data: true

      - name: Discover Conan Packages
        id: conan_search
        uses: actions/github-script@v7
        with:
          script: |
            const jiraTicket = '${{ steps.validate_input.outputs.jira_ticket_number }}';
            const buildChannel = '${{ inputs.channel }}';
            const conanPkgRef = `*/*@${buildChannel}/${jiraTicket}`;
            console.log(`Searching for Conan packages matching pattern: ${conanPkgRef}`);

            let searchResult = '';
            const options = {
              ignoreReturnCode: true,
              listeners: {
                stdout: (data) => {
                  searchResult += data.toString();
                },
                stderr: (data) => {
                  searchResult += data.toString();
                }
              }
            };

            await exec.exec('conan', ['list', conanPkgRef, '-r=*', '--format=json'], options);

            const jsonStart = searchResult.indexOf('{');
            if (jsonStart === -1) {
              console.log(`No packages found in any remote matching ${conanPkgRef}`);
              core.setOutput('discovered_packages', '');
              core.setOutput('cura_package', '');
              core.setOutput('package_overrides', '');
              
              await core.summary
                .addHeading(`Conan Packages Found for Jira Ticket: ${jiraTicket}`)
                .addRaw(`The workflow searched for Conan packages matching the pattern \`${conanPkgRef}\` across all configured remotes.`)
                .addHeading('Discovered Packages:', 2)
                .addRaw('*No packages found matching the specified tag.*')
                .addSeparator()
                .write();
              return;
            }
            
            const jsonEnd = searchResult.lastIndexOf('}');
            const jsonDataStr = searchResult.substring(jsonStart, jsonEnd + 1);
            let jsonData;
            try {
              jsonData = JSON.parse(jsonDataStr);
            } catch (e) {
              console.log(`Failed to parse conan list output as JSON: ${e.message}`);
              console.log(`Raw output: ${searchResult}`);
              core.setFailed('Failed to parse conan list output.');
              return;
            }

            const allPackages = [];
            for (const remote in jsonData) {
              if (jsonData[remote]) {
                const packages = Object.keys(jsonData[remote]);
                for (const pkg of packages) {
                  allPackages.push(pkg);
                }
              }
            }

            // Filter out packages with '+' in the name
            const discoveredPackages = allPackages.filter(pkg => !pkg.includes('+'));

            // Use Conan CLI for deduplication - get latest versions only
            const deduplicatedPackages = [];
            const packageGroups = new Map();
            
            // Group packages by name
            for (const pkg of discoveredPackages) {
              const match = pkg.match(/^([^/]+)\//);
              if (match) {
                const packageName = match[1];
                if (!packageGroups.has(packageName)) {
                  packageGroups.set(packageName, []);
                }
                packageGroups.get(packageName).push(pkg);
              }
            }
            
            // For each package group, use conan list to get the latest version
            for (const [packageName, packages] of packageGroups.entries()) {
              if (packages.length === 1) {
                deduplicatedPackages.push(packages[0]);
                continue;
              }
              
              // Use conan list with pattern to find latest version
              const packagePattern = `${packageName}/*@${buildChannel}/${jiraTicket}`;
              let latestSearchResult = '';
              const latestOptions = {
                ignoreReturnCode: true,
                listeners: {
                  stdout: (data) => {
                    latestSearchResult += data.toString();
                  },
                  stderr: (data) => {
                    latestSearchResult += data.toString();
                  }
                }
              };
              
              try {
                await exec.exec('conan', ['list', packagePattern, '-r=*', '--format=json'], latestOptions);
                
                const latestJsonStart = latestSearchResult.indexOf('{');
                if (latestJsonStart !== -1) {
                  const latestJsonEnd = latestSearchResult.lastIndexOf('}');
                  const latestJsonDataStr = latestSearchResult.substring(latestJsonStart, latestJsonEnd + 1);
                  const latestJsonData = JSON.parse(latestJsonDataStr);
                  
                  // Get all versions and let Conan's natural ordering determine the latest
                  const allVersions = [];
                  for (const remote in latestJsonData) {
                    if (latestJsonData[remote]) {
                      const remotePackages = Object.keys(latestJsonData[remote]);
                      for (const pkg of remotePackages) {
                        if (!pkg.includes('+')) {
                          allVersions.push(pkg);
                        }
                      }
                    }
                  }
                  
                  // Conan list returns packages in a consistent order, take the last one as latest
                  if (allVersions.length > 0) {
                    const latestPackage = allVersions[allVersions.length - 1];
                    deduplicatedPackages.push(latestPackage);
                    console.log(`Selected latest version for ${packageName}: ${latestPackage}`);
                  }
                }
              } catch (e) {
                console.log(`Failed to determine latest version for ${packageName}, using first found: ${packages[0]}`);
                deduplicatedPackages.push(packages[0]);
              }
            }
            console.log(`Original packages found: ${discoveredPackages.length}, after deduplication: ${deduplicatedPackages.length}`);

            const summary = core.summary
              .addHeading(`Conan Packages Found for Jira Ticket: ${jiraTicket}`)
              .addRaw(`The workflow searched for Conan packages matching the pattern \`${conanPkgRef}\` across all configured remotes.`)
              .addHeading('Discovered Packages:', 2);
            
            if (deduplicatedPackages.length === 0) {
                summary.addRaw('*No packages found matching the specified tag.*');
            } else {
                summary.addList(deduplicatedPackages);
                if (discoveredPackages.length > deduplicatedPackages.length) {
                  summary.addHeading('Package Version Selection:', 3)
                    .addRaw(`Found ${discoveredPackages.length} total packages, selected ${deduplicatedPackages.length} packages after choosing the highest semantic version for each repository.`)
                    .addHeading('All Discovered Packages (before deduplication):', 4)
                    .addList(discoveredPackages);
                }
            }
            await summary.addSeparator().write();

            let curaPackage = '';
            const overridePackages = [];
            for (const pkg of deduplicatedPackages) {
              if (pkg.startsWith('cura/')) {
                curaPackage = pkg;
              } else {
                overridePackages.push(pkg);
              }
            }

            core.setOutput('discovered_packages', deduplicatedPackages.join(' '));
            core.setOutput('cura_package', curaPackage);
            core.setOutput('package_overrides', overridePackages.join(' '));
