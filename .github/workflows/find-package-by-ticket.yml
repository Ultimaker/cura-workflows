name: Conan Package Discovery by Jira Ticket

on:
  workflow_call:
    inputs:
      jira_ticket_number:
        default: ''
        required: true
        type: string
      channel:
        default: 'ultimaker'
        required: false
        type: string
    outputs:
      discovered_packages:
        description: "All discovered packages"
        value: ${{ jobs.find-packages.outputs.discovered_packages }}
      cura_package:
        description: "Cura package"
        value: ${{ jobs.find-packages.outputs.cura_package }}
      package_overrides:
        description: "Overrides"
        value: ${{ jobs.find-packages.outputs.package_overrides }}

permissions:
  contents: read

jobs:
  find-packages:
    runs-on: ubuntu-latest
    outputs:
      discovered_packages: ${{ steps.conan_search.outputs.discovered_packages }}
      cura_package: ${{ steps.conan_search.outputs.cura_package }}
      package_overrides: ${{ steps.conan_search.outputs.package_overrides }}
    steps:
      - name: Checkout repository code
        uses: actions/checkout@v4

      - name: Validate Jira Ticket Number Format
        id: validate_input
        uses: actions/github-script@v7
        with:
          script: |
            const inputTicket = '${{ inputs.jira_ticket_number }}';
            let normalizedTicket = inputTicket.toLowerCase().replace(/-/g, '_');

            if (/^[0-9]+$/.test(normalizedTicket)) {
              normalizedTicket = `cura_${normalizedTicket}`;
            }

            const keyword = normalizedTicket.split('_')[0];
            const numberMatch = normalizedTicket.match(/[0-9]+/);
            const number = numberMatch ? numberMatch[0] : null;

            if (!['cura', 'np', 'pp'].includes(keyword)) {
              return core.setFailed("Invalid Jira ticket keyword. Expected one of: cura, np, pp.");
            }
            if (number === null) {
              return core.setFailed("No number found in Jira ticket input.");
            }

            const fixedTicket = `${keyword}_${number}`;
            console.log(`Jira ticket number normalized to '${fixedTicket}'.`);
            core.setOutput('jira_ticket_number', fixedTicket);

      - name: Setup the build environment
        uses: ultimaker/cura-workflows/.github/actions/setup-build-environment@main
        with:
          conan_user: ${{ secrets.CONAN_USER }}
          conan_password: ${{ secrets.CONAN_PASS }}
          private_data: true

      - name: Discover Conan Packages
        id: conan_search
        uses: actions/github-script@v7
        with:
          script: |
            const jiraTicket = '${{ steps.validate_input.outputs.jira_ticket_number }}';
            const buildChannel = '${{ inputs.channel }}'
            const conanPkgRef = `*/*@${buildChannel}/${jiraTicket}`;
            console.log(`Searching for Conan packages matching pattern: ${conanPkgRef}`);

            // Function to compare semantic versions
            function compareVersions(a, b) {
              const aParts = a.split('.').map(x => parseInt(x) || 0);
              const bParts = b.split('.').map(x => parseInt(x) || 0);
              const maxLength = Math.max(aParts.length, bParts.length);
              
              for (let i = 0; i < maxLength; i++) {
                const aPart = aParts[i] || 0;
                const bPart = bParts[i] || 0;
                if (aPart > bPart) return 1;
                if (aPart < bPart) return -1;
              }
              return 0;
            }

            // Function to deduplicate packages by selecting highest version for each repository
            function deduplicatePackages(packages) {
              const packageMap = new Map();
              
              for (const pkg of packages) {
                // Extract package name and version from format "packagename/version"
                const match = pkg.match(/^([^\/]+)\/(.+)$/);
                if (!match) continue;
                
                const [, packageName, version] = match;
                
                if (!packageMap.has(packageName)) {
                  packageMap.set(packageName, { package: pkg, version: version });
                } else {
                  const existing = packageMap.get(packageName);
                  if (compareVersions(version, existing.version) > 0) {
                    packageMap.set(packageName, { package: pkg, version: version });
                    console.log(`Found higher version for ${packageName}: ${version} > ${existing.version}, selecting ${pkg}`);
                  } else {
                    console.log(`Keeping existing version for ${packageName}: ${existing.version} >= ${version}`);
                  }
                }
              }
              
              return Array.from(packageMap.values()).map(item => item.package);
            }

            let searchResult = '';
            const options = {
              ignoreReturnCode: true,
              listeners: {
                stdout: (data) => {
                  searchResult += data.toString();
                },
                stderr: (data) => {
                  searchResult += data.toString();
                }
              }
            };

            await exec.exec('conan', ['list', conanPkgRef, '-r=*', '--format=json'], options);

            const jsonStart = searchResult.indexOf('{');
            if (jsonStart === -1) {
              console.log(`No packages found in any remote matching ${conanPkgRef}`);
              core.setOutput('discovered_packages', '');
              core.setOutput('cura_package', '');
              core.setOutput('package_overrides', '');
              
              await core.summary
                .addHeading(`Conan Packages Found for Jira Ticket: ${jiraTicket}`)
                .addRaw(`The workflow searched for Conan packages matching the pattern \`${conanPkgRef}\` across all configured remotes.`)
                .addHeading('Discovered Packages:', 2)
                .addRaw('*No packages found matching the specified tag.*')
                .addSeparator()
                .write();
              return;
            }
            
            const jsonEnd = searchResult.lastIndexOf('}');
            const jsonDataStr = searchResult.substring(jsonStart, jsonEnd + 1);
            let jsonData;
            try {
              jsonData = JSON.parse(jsonDataStr);
            } catch (e) {
              console.log(`Failed to parse conan list output as JSON: ${e.message}`);
              console.log(`Raw output: ${searchResult}`);
              core.setFailed('Failed to parse conan list output.');
              return;
            }

            const allPackages = [];
            for (const remote in jsonData) {
              if (jsonData[remote]) {
                const packages = Object.keys(jsonData[remote]);
                for (const pkg of packages) {
                  allPackages.push(pkg);
                }
              }
            }

            // Filter out packages with '+' in the name
            const discoveredPackages = allPackages.filter(pkg => !pkg.includes('+'));

            // Apply deduplication to select highest versions for each repository
            const deduplicatedPackages = deduplicatePackages(discoveredPackages);
            console.log(`Original packages found: ${discoveredPackages.length}, after deduplication: ${deduplicatedPackages.length}`);

            const summary = core.summary
              .addHeading(`Conan Packages Found for Jira Ticket: ${jiraTicket}`)
              .addRaw(`The workflow searched for Conan packages matching the pattern \`${conanPkgRef}\` across all configured remotes.`)
              .addHeading('Discovered Packages:', 2);
            
            if (deduplicatedPackages.length === 0) {
                summary.addRaw('*No packages found matching the specified tag.*');
            } else {
                summary.addList(deduplicatedPackages);
                if (discoveredPackages.length > deduplicatedPackages.length) {
                  summary.addHeading('Package Version Selection:', 3)
                    .addRaw(`Found ${discoveredPackages.length} total packages, selected ${deduplicatedPackages.length} packages after choosing the highest semantic version for each repository.`);
                }
            }
            await summary.addSeparator().write();

            let curaPackage = '';
            const overridePackages = [];
            for (const pkg of deduplicatedPackages) {
              if (pkg.startsWith('cura/')) {
                curaPackage = pkg;
              } else {
                overridePackages.push(pkg);
              }
            }

            core.setOutput('discovered_packages', deduplicatedPackages.join(' '));
            core.setOutput('cura_package', curaPackage);
            core.setOutput('package_overrides', overridePackages.join(' '));
